{% extends "base.html" %}

{% block title %}Settings - The A√ßa√≠ Truck Admin{% endblock %}

{% block nav_settings %}active{% endblock %}

{% block page_title %}Bot Settings{% endblock %}

{% block content %}
<!-- Page Header -->
<div class="page-header">
    <p class="page-subtitle">Adjust menu options, branding, and pricing</p>
</div>

<div class="card mb-6">
    <div class="card-header">
        <h3 class="card-title mb-0"><i class="bi bi-stars"></i> Bot Branding & Welcome</h3>
    </div>
    <div class="card-body">
        <div class="mb-3">
            <label class="form-label">Welcome Title</label>
            <input type="text" class="form-control" id="brandingTitle" value="{{ branding.title }}" placeholder="üçß Welcome to Acai Supper Bot!">
        </div>
        <div class="mb-3">
            <label class="form-label">Subtitle</label>
            <textarea class="form-control" id="brandingSubtitle" rows="3" placeholder="Short description shown in the Telegram welcome message">{{ branding.subtitle }}</textarea>
        </div>
        <div class="mb-3">
            <label class="form-label">Hero Image</label>
            <input class="form-control" type="file" id="brandingImageFile" accept="image/png, image/jpeg, image/webp">
            <div id="brandingImageUploadStatus" class="form-text">PNG/JPG/WebP up to 2MB. Uploading will automatically update the preview and save the image.</div>
            <div class="d-flex align-items-center gap-3 mt-3">
                <div class="flex-shrink-0" style="width: 120px;">
                    <img id="brandingPreviewImage" class="img-fluid rounded shadow-sm" alt="Branding preview" src="{{ branding.image_url or '' }}" {% if not branding.image_url %}style="display:none;"{% endif %}>
                    <div id="brandingPreviewImagePlaceholder" class="border rounded d-flex align-items-center justify-content-center text-muted py-4 px-3" {% if branding.image_url %}style="display:none;"{% endif %}>
                        No image uploaded
                    </div>
                </div>
                <button class="btn btn-outline-secondary btn-sm" type="button" id="clearBrandingImageBtn">
                    <i class="bi bi-eraser"></i> Remove Image
                </button>
            </div>
        </div>
        <div class="mb-3">
            <label class="form-label small text-muted">Preview</label>
            <div class="border rounded p-3 bg-light">
                <h5 id="brandingPreviewTitle" class="mb-1">{{ branding.title or 'üçß Welcome to Acai Supper Bot!' }}</h5>
                <p id="brandingPreviewSubtitle" class="mb-0 text-muted">{{ branding.subtitle }}</p>
            </div>
        </div>
        <button class="btn-success" id="saveBrandingBtn">
            <i class="bi bi-save"></i> Save Branding
        </button>
    </div>
</div>

<div class="card mb-6">
    <div class="card-header d-flex justify-content-between align-items-center">
        <div>
            <h3 class="card-title mb-0"><i class="bi bi-cash-stack"></i> Pricing</h3>
            <p class="mb-0 text-muted small">Set the base bowl price and currency shown to users</p>
        </div>
    </div>
    <div class="card-body">
        <div class="mb-3">
            <label class="form-label">Price per bowl (<span id="pricingCurrencyLabel">{{ pricing.currency or 'SGD' }}</span>)</label>
            <input type="number" class="form-control" id="pricePerBowl" step="0.01" value="{{ pricing.price_per_bowl }}">
        </div>
        <div class="mb-3">
            <label class="form-label">Currency</label>
            <input type="text" class="form-control text-uppercase" id="currency" maxlength="3" value="{{ pricing.currency or 'SGD' }}" placeholder="SGD">
            <small class="text-muted">Use a 3-letter currency code (e.g., SGD, USD).</small>
        </div>
        <button class="btn-success" id="savePricingBtn">
            <i class="bi bi-save"></i> Save Pricing
        </button>
    </div>
</div>

<!-- Menu Groups -->
<div class="card mb-6">
    <div class="card-header d-flex justify-content-between align-items-center">
        <div>
            <h3 class="card-title mb-0"><i class="bi bi-list-check"></i> Menu Option Groups</h3>
            <p class="mb-0 text-muted small">Configure flavors, sauces, and other add-ons shown in the bot</p>
        </div>
        <div class="btn-group">
            <button class="btn btn-outline-primary" type="button" id="addMenuGroupBtn">
                <i class="bi bi-plus"></i> Add Group
            </button>
            <button class="btn-success" type="button" id="saveMenuGroupsBtn">
                <i class="bi bi-save"></i> Save Menu
            </button>
        </div>
    </div>
    <div class="card-body">
        <div id="menuGroupsContainer" class="row g-3"></div>
    </div>
</div>

<!-- Order Verification Message -->
<div class="card mb-6">
    <div class="card-header">
        <h3 class="card-title"><i class="bi bi-chat-dots"></i> Order Verification Message</h3>
    </div>
    <div class="card-body">
        <p class="text-muted mb-3">This message is sent to customers via Telegram when you verify their payment. You can use the following variables which will be automatically replaced:</p>
        <div class="alert alert-info small mb-3">
            <strong>Available Variables:</strong><br>
            <code>{customer_name}</code> - Customer's name<br>
            <code>{order_id}</code> - Order ID<br>
            <code>{total_price}</code> - Order total (formatted as currency)<br>
            <code>{delivery_location}</code> - Delivery location (for delivery orders)<br>
            <code>{delivery_time}</code> - Delivery date/time (for delivery orders)
        </div>
        <div class="mb-3">
            <label class="form-label">Verification Message Template</label>
            <textarea class="form-control" id="verificationMessage" rows="4" placeholder="Hi {customer_name}, your order #{order_id} has been confirmed! Total: {total_price}. Thank you!">{{ verification_message }}</textarea>
            <small class="text-muted">This message will be sent in Telegram when the admin verifies an order payment.</small>
        </div>
        <div class="mb-3">
            <label class="form-label small text-muted">Preview</label>
            <div class="border rounded p-3 bg-light">
                <strong>To: Jane Doe</strong>
                <p id="verificationMessagePreview" class="mb-0" style="white-space: pre-wrap; word-wrap: break-word;">{{ verification_message|replace('{customer_name}', 'Jane Doe')|replace('{order_id}', 'ORD123')|replace('{total_price}', '$8.00')|replace('{delivery_location}', 'SUTD')|replace('{delivery_time}', 'Tomorrow 3:00 PM') }}</p>
            </div>
        </div>
        <button class="btn-success" id="saveVerificationMessageBtn">
            <i class="bi bi-save"></i> Save Message
        </button>
    </div>
</div>

<!-- Broadcast to All Customers -->
<div class="card mb-6">
    <div class="card-header">
        <h3 class="card-title mb-0"><i class="bi bi-megaphone"></i> Broadcast to All Customers</h3>
        <p class="text-muted mb-0 small">Send a message to all customers with Telegram accounts. Optional image upload.</p>
    </div>
    <div class="card-body">
        <div class="mb-3">
            <label class="form-label">Message</label>
            <textarea class="form-control" id="customerBroadcastMessage" rows="3" placeholder="Enter the broadcast message"></textarea>
        </div>
        <div class="mb-3">
            <label class="form-label">Image (optional)</label>
            <input type="file" class="form-control" id="customerBroadcastImageFile" accept="image/png, image/jpeg, image/webp">
            <small class="text-muted">PNG/JPG/WebP up to 2MB.</small>
        </div>
        <button class="btn-success" id="customerBroadcastSendBtn">
            <i class="bi bi-send"></i> Send Broadcast
        </button>
        <div id="customerBroadcastStatus" class="mt-2 text-muted small"></div>
    </div>
</div>{% endblock %}

{% block extra_scripts %}
<script>
    const brandingData = {{ branding|tojson|default('null', true) }};
    const menuGroupsData = {{ menu_groups|tojson|default('[]', true) }};
    const pricingData = {{ pricing|tojson|default('null', true) }};

let menuGroups = Array.isArray(menuGroupsData) ? JSON.parse(JSON.stringify(menuGroupsData)) : [];
let branding = Object.assign({}, brandingData || {});
let pricing = Object.assign({}, pricingData || {});

const menuGroupsContainer = document.getElementById('menuGroupsContainer');
const brandingTitleInput = document.getElementById('brandingTitle');
const brandingSubtitleInput = document.getElementById('brandingSubtitle');
const brandingPreviewTitle = document.getElementById('brandingPreviewTitle');
const brandingPreviewSubtitle = document.getElementById('brandingPreviewSubtitle');
const brandingPreviewImage = document.getElementById('brandingPreviewImage');
const brandingImagePlaceholder = document.getElementById('brandingPreviewImagePlaceholder');
const brandingImageFileInput = document.getElementById('brandingImageFile');
const brandingImageUploadStatus = document.getElementById('brandingImageUploadStatus');
const clearBrandingImageBtn = document.getElementById('clearBrandingImageBtn');

// Track the current branding image URL
let currentBrandingImageUrl = branding.image_url || '';
const pricingCurrencyLabel = document.getElementById('pricingCurrencyLabel');
const pricePerBowlInput = document.getElementById('pricePerBowl');
const currencyInput = document.getElementById('currency');

const saveMenuGroupsBtn = document.getElementById('saveMenuGroupsBtn');
const addMenuGroupBtn = document.getElementById('addMenuGroupBtn');
const saveBrandingBtn = document.getElementById('saveBrandingBtn');
const savePricingBtn = document.getElementById('savePricingBtn');
const verificationMessageInput = document.getElementById('verificationMessage');
const saveVerificationMessageBtn = document.getElementById('saveVerificationMessageBtn');
const verificationMessagePreview = document.getElementById('verificationMessagePreview');
const customerBroadcastMessageInput = document.getElementById('customerBroadcastMessage');
const customerBroadcastImageFileInput = document.getElementById('customerBroadcastImageFile');
const customerBroadcastSendBtn = document.getElementById('customerBroadcastSendBtn');
const customerBroadcastStatus = document.getElementById('customerBroadcastStatus');

const daysOfWeek = [
    { key: 'monday', label: 'Monday' },
    { key: 'tuesday', label: 'Tuesday' },
    { key: 'wednesday', label: 'Wednesday' },
    { key: 'thursday', label: 'Thursday' },
    { key: 'friday', label: 'Friday' },
    { key: 'saturday', label: 'Saturday' },
    { key: 'sunday', label: 'Sunday' },
];

function escapeHtml(value = '') {
    return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

function slugify(value, fallback = 'group') {
    const base = (value || '')
        .toString()
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
    return base || fallback;
}

function makeUniqueSlug(base, used) {
    let slug = base;
    let counter = 2;
    while (used.has(slug)) {
        slug = `${base}-${counter++}`;
    }
    used.add(slug);
    return slug;
}

function generateClientGroupId(seed = '') {
    const used = new Set(menuGroups.map(g => g.id).filter(Boolean));
    const base = slugify(seed, `group-${used.size + 1}`);
    return makeUniqueSlug(base, used);
}

function renderBrandingPreview() {
    if (brandingPreviewTitle) {
        brandingPreviewTitle.textContent = brandingTitleInput.value.trim() || 'üçß Welcome to Acai Supper Bot!';
    }
    if (brandingPreviewSubtitle) {
        brandingPreviewSubtitle.textContent = brandingSubtitleInput.value.trim();
    }
}

function updateBrandingImagePreview() {
    if (!brandingPreviewImage || !brandingImagePlaceholder) return;
    const url = currentBrandingImageUrl.trim();
    if (url) {
        brandingPreviewImage.src = url;
        brandingPreviewImage.style.display = 'block';
        brandingImagePlaceholder.style.display = 'none';
        if (clearBrandingImageBtn) {
            clearBrandingImageBtn.disabled = false;
        }
    } else {
        brandingPreviewImage.removeAttribute('src');
        brandingPreviewImage.style.display = 'none';
        brandingImagePlaceholder.style.display = 'flex';
        if (clearBrandingImageBtn) {
            clearBrandingImageBtn.disabled = true;
        }
    }
}

const BRANDING_IMAGE_MAX_SIZE = 2 * 1024 * 1024;
const BRANDING_UPLOAD_HELP_TEXT = 'PNG/JPG/WebP up to 2MB. Uploading will automatically update the preview and save the image.';

function setBrandingUploadState(isUploading) {
    if (brandingImageFileInput) {
        brandingImageFileInput.disabled = isUploading;
    }
    if (brandingImageUploadStatus) {
        brandingImageUploadStatus.textContent = isUploading ? 'Uploading image‚Ä¶' : BRANDING_UPLOAD_HELP_TEXT;
    }
}

async function handleBrandingImageFileChange(event) {
    const file = event.target.files && event.target.files[0];
    if (!file) return;

    if (!file.type || !file.type.startsWith('image/')) {
        showToast('Please choose an image file (PNG/JPG/WebP).', 'warning');
        event.target.value = '';
        return;
    }

    if (file.size > BRANDING_IMAGE_MAX_SIZE) {
        showToast('Image must be 2MB or smaller.', 'danger');
        event.target.value = '';
        return;
    }

    setBrandingUploadState(true);

    try {
        const formData = new FormData();
        formData.append('file', file);

        const response = await fetch('/api/settings/branding/image', {
            method: 'POST',
            body: formData
        });
        const data = await response.json();

        if (!response.ok || !data.success || !data.url) {
            throw new Error(data.detail || data.message || 'Failed to upload branding image');
        }

        currentBrandingImageUrl = data.url;
        updateBrandingImagePreview();
        showToast('Image uploaded. Don\'t forget to save branding.', 'success');
    } catch (error) {
        console.error(error);
        showToast(error.message || 'Unable to upload image', 'danger');
    } finally {
        setBrandingUploadState(false);
        event.target.value = '';
    }
}

function renderMenuGroups() {
    if (!menuGroupsContainer) return;
    if (!Array.isArray(menuGroups) || menuGroups.length === 0) {
        menuGroups = [{
            id: generateClientGroupId('option-group'),
            title: 'Option Group',
            options: ['']
        }];
    }

    menuGroupsContainer.innerHTML = menuGroups.map((group, index) => {
        const safeTitle = escapeHtml(group.title || '');
        const options = (group.options && group.options.length ? group.options : ['']);
        const optionsHtml = options.map((option, optionIndex) => {
            const safeOption = escapeHtml(option || '');
            return `
                <div class="input-group input-group-sm mb-2" data-option-index="${optionIndex}">
                    <input type="text" class="form-control option-input" value="${safeOption}" placeholder="Option name">
                    <button class="btn btn-outline-danger" type="button" onclick="removeMenuOption(${index}, ${optionIndex})">
                        <i class="bi bi-x"></i>
                    </button>
                </div>
            `;
        }).join('');

        return `
            <div class="col-lg-6" data-group-index="${index}">
                <div class="card h-100 shadow-sm">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <div class="w-100 me-2">
                            <label class="form-label small text-muted">Group Title</label>
                            <input type="text" class="form-control form-control-sm group-title" value="${safeTitle}" placeholder="e.g., Fruit Toppings">
                        </div>
                        <button class="btn btn-sm btn-outline-danger ms-2" type="button" onclick="removeMenuGroup(${index})" title="Remove group">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                    <div class="card-body">
                        <label class="form-label small text-muted">Options</label>
                        <div class="menu-options" data-options-container>
                            ${optionsHtml}
                        </div>
                        <button class="btn btn-sm btn-outline-primary" type="button" onclick="addMenuOption(${index})">
                            <i class="bi bi-plus"></i> Add Option
                        </button>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

function collectMenuGroupValues() {
    if (!menuGroupsContainer) return;
    const cards = menuGroupsContainer.querySelectorAll('[data-group-index]');
    const currentGroups = menuGroups.slice();
    const usedIds = new Set();

    const updatedGroups = Array.from(cards).map(card => {
        const domIndex = parseInt(card.getAttribute('data-group-index'), 10);
        const original = currentGroups[domIndex] || {};
        const titleInput = card.querySelector('.group-title');
        const optionInputs = card.querySelectorAll('.option-input');
        const title = titleInput ? titleInput.value.trim() : '';
        const options = Array.from(optionInputs).map(input => input.value.trim());

        let id = (original.id || '').trim();
        if (!id) {
            const base = slugify(title || `group-${domIndex + 1}`);
            id = makeUniqueSlug(base, usedIds);
        } else if (usedIds.has(id)) {
            id = makeUniqueSlug(id, usedIds);
        } else {
            usedIds.add(id);
        }

        return { id, title, options };
    });

    menuGroups = updatedGroups;
}

function addMenuGroup() {
    collectMenuGroupValues();
    menuGroups.push({
        id: generateClientGroupId('option-group'),
        title: '',
        options: ['']
    });
    renderMenuGroups();
}

function removeMenuGroup(index) {
    collectMenuGroupValues();
    if (menuGroups.length <= 1) {
        showToast('At least one option group is required', 'warning');
        return;
    }
    menuGroups.splice(index, 1);
    renderMenuGroups();
}

function addMenuOption(groupIndex) {
    collectMenuGroupValues();
    if (!menuGroups[groupIndex]) return;
    menuGroups[groupIndex].options.push('');
    renderMenuGroups();
}

function removeMenuOption(groupIndex, optionIndex) {
    collectMenuGroupValues();
    const group = menuGroups[groupIndex];
    if (!group) return;
    if ((group.options || []).length <= 1) {
        showToast('Each group must have at least one option', 'warning');
        return;
    }
    group.options.splice(optionIndex, 1);
    renderMenuGroups();
}

async function saveMenuGroups(event) {
    if (event) event.preventDefault();
    collectMenuGroupValues();

    if (!menuGroups.length) {
        showToast('Add at least one option group', 'danger');
        return;
    }

    const usedIds = new Set();
    const sanitizedGroups = [];
    for (const group of menuGroups) {
        const title = (group.title || '').trim();
        if (!title) {
            showToast('Each group must have a title', 'danger');
            return;
        }
        const options = (group.options || []).map(option => option.trim()).filter(Boolean);
        if (!options.length) {
            showToast(`"${title}" must contain at least one option`, 'danger');
            return;
        }

        let id = (group.id || '').trim();
        if (!id) {
            id = slugify(title, `group-${sanitizedGroups.length + 1}`);
        } else {
            id = slugify(id, id);
        }
        id = makeUniqueSlug(id, usedIds);

        sanitizedGroups.push({ id, title, options });
    }

    const button = saveMenuGroupsBtn;
    if (!button) return;
    button.disabled = true;
    showLoading(button);

    try {
        const response = await fetch('/api/settings/menu-groups', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ groups: sanitizedGroups })
        });
        const payload = await response.json();
        if (!response.ok || !payload.success) {
            throw new Error(payload.detail || payload.message || 'Failed to update menu options');
        }
        menuGroups = sanitizedGroups.map(group => ({ ...group, options: [...group.options] }));
        renderMenuGroups();
        showToast('Menu options updated', 'success');
    } catch (error) {
        console.error(error);
        showToast(error.message || 'Unable to save menu options', 'danger');
    } finally {
        hideLoading(button);
        button.disabled = false;
    }
}

async function saveBranding(event) {
    if (event) event.preventDefault();
    const payload = {
        title: brandingTitleInput.value.trim(),
        subtitle: brandingSubtitleInput.value.trim(),
        image_url: currentBrandingImageUrl.trim()
    };

    const button = saveBrandingBtn;
    if (!button) return;
    button.disabled = true;
    showLoading(button);

    try {
        const response = await fetch('/api/settings/branding', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        const data = await response.json();
        if (!response.ok || !data.success) {
            throw new Error(data.detail || data.message || 'Failed to update branding');
        }
        branding = { ...payload };
        renderBrandingPreview();
        updateBrandingImagePreview();
        showToast('Branding updated', 'success');
    } catch (error) {
        console.error(error);
        showToast(error.message || 'Unable to save branding', 'danger');
    } finally {
        hideLoading(button);
        button.disabled = false;
    }
}

async function savePricing(event) {
    if (event) event.preventDefault();
    const priceValue = parseFloat(pricePerBowlInput.value || '0');
    const currencyValue = (currencyInput.value || '').trim().toUpperCase();

    if (!currencyValue || currencyValue.length !== 3) {
        showToast('Currency must be a 3-letter code', 'danger');
        return;
    }

    const button = savePricingBtn;
    if (!button) return;
    button.disabled = true;
    showLoading(button);

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 12000);

    try {
        const response = await fetch('/api/settings/pricing', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ value: { price_per_bowl: priceValue, currency: currencyValue } }),
            signal: controller.signal
        });
        const data = await response.json().catch(() => ({}));
        if (!response.ok || !data.success) {
            throw new Error(data.detail || data.message || 'Failed to update pricing');
        }
        pricing.currency = currencyValue;
        pricing.price_per_bowl = priceValue;
        pricingCurrencyLabel.textContent = currencyValue;
        showToast('Pricing updated', 'success');
    } catch (error) {
        if (error.name === 'AbortError') {
            showToast('Pricing update timed out. Please try again.', 'danger');
        } else {
            console.error(error);
            showToast(error.message || 'Unable to save pricing', 'danger');
        }
    } finally {
        clearTimeout(timeoutId);
        hideLoading(button);
        button.disabled = false;
    }
}

// Load verification message on page load
async function loadVerificationMessage() {
    try {
        const response = await fetch('/api/settings/verification-message');
        const payload = await response.json();
        if (payload.success && payload.data) {
            const message = payload.data.message || '';
            if (verificationMessageInput) {
                verificationMessageInput.value = message;
                updateVerificationMessagePreview();
            }
        }
    } catch (error) {
        console.error('Error loading verification message:', error);
    }
}

function updateVerificationMessagePreview() {
    if (!verificationMessageInput || !verificationMessagePreview) return;

    const template = verificationMessageInput.value;
    // Replace variables with sample values
    const preview = template
        .replace(/{customer_name}/g, 'Jane Doe')
        .replace(/{order_id}/g, 'ORD123')
        .replace(/{total_price}/g, '$8.00')
        .replace(/{delivery_location}/g, 'SUTD')
        .replace(/{delivery_time}/g, 'Tomorrow 3:00 PM')
        

    verificationMessagePreview.textContent = preview;
}

async function saveVerificationMessage() {
    try {
        const message = (verificationMessageInput.value || '').trim();
        if (!message) {
            showToast('Message cannot be empty', 'warning');
            return;
        }

        const response = await fetch('/api/settings/verification-message', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message })
        });

        const payload = await response.json();
        if (!payload.success) throw new Error(payload.detail || 'Failed to save message');

        showToast('‚úì Verification message saved successfully', 'success');
    } catch (error) {
        console.error(error);
        showToast('Failed to save verification message: ' + error.message, 'danger');
    }
}

async function sendCustomerBroadcast() {
    const message = (customerBroadcastMessageInput.value || '').trim();
    const imageFile = customerBroadcastImageFileInput?.files?.[0];

    if (!message) {
        showToast('Message cannot be empty', 'danger');
        return;
    }
    if (imageFile) {
        if (!imageFile.type.startsWith('image/')) {
            showToast('Please choose an image file (PNG/JPG/WebP)', 'danger');
            return;
        }
        if (imageFile.size > 2 * 1024 * 1024) {
            showToast('Image must be 2MB or smaller', 'danger');
            return;
        }
    }

    if (customerBroadcastSendBtn) {
        customerBroadcastSendBtn.disabled = true;
        showLoading(customerBroadcastSendBtn);
    }
    if (customerBroadcastStatus) {
        customerBroadcastStatus.textContent = 'Sending...';
    }

    try {
        const formData = new FormData();
        formData.append('message', message);
        if (imageFile) {
            formData.append('image', imageFile);
        }

        const response = await fetch('/api/customers/broadcast', {
            method: 'POST',
            body: formData
        });
        const payload = await response.json();
        if (!response.ok || !payload.success) {
            throw new Error(payload.detail || payload.message || 'Failed to send broadcast');
        }
        const failed = payload.failed || [];
        const sent = payload.sent || 0;
        if (customerBroadcastStatus) {
            customerBroadcastStatus.textContent = `Sent to ${sent} recipient(s)` + (failed.length ? `, ${failed.length} failed` : '');
        }
        if (failed.length) {
            showToast(`Sent to ${sent}, ${failed.length} failed`, 'warning');
            console.warn('Customer broadcast failures', failed);
        } else {
            showToast(`Sent to ${sent} recipient(s)`, 'success');
        }
    } catch (error) {
        console.error(error);
        if (customerBroadcastStatus) {
            customerBroadcastStatus.textContent = 'Send failed';
        }
        showToast('Unable to send broadcast: ' + error.message, 'danger');
    } finally {
        if (customerBroadcastSendBtn) {
            hideLoading(customerBroadcastSendBtn);
            customerBroadcastSendBtn.disabled = false;
        }
    }
}

if (addMenuGroupBtn) {
    addMenuGroupBtn.addEventListener('click', addMenuGroup);
}

if (saveMenuGroupsBtn) {
    saveMenuGroupsBtn.addEventListener('click', saveMenuGroups);
}

if (saveBrandingBtn) {
    saveBrandingBtn.addEventListener('click', saveBranding);
}

if (savePricingBtn) {
    savePricingBtn.addEventListener('click', savePricing);
}

if (brandingTitleInput) {
    brandingTitleInput.addEventListener('input', renderBrandingPreview);
}

if (brandingSubtitleInput) {
    brandingSubtitleInput.addEventListener('input', renderBrandingPreview);
}

if (brandingImageFileInput) {
    brandingImageFileInput.addEventListener('change', handleBrandingImageFileChange);
}

if (clearBrandingImageBtn) {
    clearBrandingImageBtn.addEventListener('click', () => {
        currentBrandingImageUrl = '';
        updateBrandingImagePreview();
        showToast('Branding image cleared. Don\'t forget to save branding.', 'info');
    });
}

if (currencyInput) {
    currencyInput.addEventListener('input', () => {
        const value = (currencyInput.value || '').trim().toUpperCase();
        if (pricingCurrencyLabel) {
            pricingCurrencyLabel.textContent = value || (pricing.currency || 'SGD');
        }
    });
    currencyInput.value = (currencyInput.value || '').trim().toUpperCase();
}

if (pricingCurrencyLabel) {
    pricingCurrencyLabel.textContent = (pricing.currency || pricingCurrencyLabel.textContent || 'SGD').toUpperCase();
}

if (verificationMessageInput) {
    verificationMessageInput.addEventListener('input', updateVerificationMessagePreview);
}

if (saveVerificationMessageBtn) {
    saveVerificationMessageBtn.addEventListener('click', saveVerificationMessage);
}

if (customerBroadcastSendBtn) {
    customerBroadcastSendBtn.addEventListener('click', sendCustomerBroadcast);
}

setBrandingUploadState(false);
renderMenuGroups();
renderBrandingPreview();
updateBrandingImagePreview();

loadVerificationMessage();

// Expose menu functions to window for inline onclick handlers
window.addMenuOption = addMenuOption;
window.removeMenuOption = removeMenuOption;
window.removeMenuGroup = removeMenuGroup;
</script>
{% endblock %}
